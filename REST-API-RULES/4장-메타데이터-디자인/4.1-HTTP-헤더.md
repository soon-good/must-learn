# 4.1 HTTP 헤더

## 참고자료

[일관성 있는 웹 서비스 인터페이스 설계를 위한 REST API 디자인 규칙](www.yes24.com/Product/Goods/17945500) 



## HTTP 헤더

HTTP 는 표준 헤더들의 집합을 정의하고 있다. 이 중 일부는 요청된 리소스에 관련된 정보를 제공한다.  

- 이 중 몇몇 헤더는 메시지에 전달되는 표현 관련 정보를 나타낸다.

- 또는 중간 캐시를 조절하는 지시자 역할을 한다.

  

## Content-Type 을 사용해야한다.

Content-Type 헤더는 요청/응답 메시지 바디 내의 데이터 타입을 나타낸다.('4.2-미디어 타입' 참고)

클라이언트와 서버는 이 헤더 값을 참조해 메시지 바디에 있는 바이트열 처리 방법을 결정한다.  


## Content-Length 를 사용해야 한다.

Content-Length 헤더는 바이트 단위로 바디의 크기를 나타낸다. Content-Length 헤더를 사용할 경우의 장점들은 아래와 같다.

- 클라이언트는 Content-Length 헤더 값을 이용해 바이트의 크기를 올바로 읽었는지 파악할 수 있다.
- HEAD 요청을 사용해 데이터를 다운로드 하지 않고도 바디의 사이즈가 어느 정도인지 파악할 수 있다.

  

## Last-Modified 는 응답에 사용해야 한다.

Last Modified 헤더는 응답 메시지에만 사용한다. 

- Last Modified 에 정의된 값은 타임스탬프로, 리소스의 표현 상태 값이 바뀐 마지막 시간을 나타낸다.
- 클라이언트와 메시지 중간자는 이 헤더값으로 클라이언트에 저장되어 있는 리소스 상태 표현의 갱신 여부를 결정한다.



## ETag 는 응답에 사용해야 한다.

ETag 값은 응답 엔티티에 포함된 표현 상태의 특정 버전을 나타내는 일련의 문자열이다.

**TODO** ETag 에 대해서는 자료를 좀더 조사해봐야 이해가 갈 것 같다.







## 스토어는 조건부 PUT 요청을 지원해야 한다.

스토어 리소스는 PUT 메서드를 이용해 리소스를 새로 추가하거나 갱신할 수 있다.  

리소스를 추가하거나 갱신하는데에 사용되기 때문에 REST API 는 클라이언트가 사용한 PUT 메서드가 무엇을 위한 요청이었는지 파악하기 쉽지 않다.

HTTP 규약에는 이러한 모호함에 대해 기술할 수 있는 아래와 같은 헤더들을 지원한다. 

- **If-Unmodified-Since**
  
  - REST API 에게 리소스의 상태 표현이 헤더 값에 표현된 타임스탬프 시간 이후로 바뀌지 않았을 경우에만 동작하도록 기술
- **If-Match**
  - 엔티티 태그
  - 클라이언트가 받은 이전 응답의 ETag 헤더 값이다.
  - If-Match 헤더는 요청을 조건부(조건식)로 만들어낸다.
  - 헤더에 제공된 엔티티 태그 값과 REST API 에 의해 계산된 **표현 상태** 의 현재 태그값의 정확한 비교를 통해 수행한다.

  

**예제)**  

클라이언트 client #1, client#2 는 REST API 의 /objects 스토어 리소스를 통해 데이터를 공유한다.

- client#1
  - /objects/2113 으로 새로운 데이터를 저장하기 위해 PUT 요청을 했다.
    (책에서는 조금 더 멋있는 말로 **/objects/2113으로 식별되는 새로운 데이터** 라는 말을 하지만, 공부하는 입장에서는 멋있는 말을 음미하는 것은 본질을 흐리기만 할뿐.)
  - 이 새로운 URI 는 스토어에 없는 데이터이다. REST API 입장에서는 처음보는 데이터이다. REST API 는 이 요청을 INSERT 로 해석한다.
  - 새로운 리소스를 생성하고 응답으로 201("Created")를 보낸다.

- client#2
  - **/object/2113** 을 요청한다.
  - REST API 는 URI가 이미 있는 리소스라는 것을 알고 있다. 
  - BUT, 생성을 할지 갱신을 할지 REST API 입장에서는 알 수 없다.
  - client#1 의 저장된 리소스 상태에 client#2가 요청한 새로운 데이터를 덮어쓸지 충분한 정보를 REST API 가 받지 못했기 때문이다.
  - 이 경우 응답으로 409("Conflict")를 주어야 한다.
- client #2
  - 클라이언트가 데이터를 갱신하려고 할 경우
  - If-Matched 헤더를 포함해서 재요청 하면 된다.
  - 제공된 If-Matched 헤더 값 조건이 현재의 엔티티 값이 같지 않을 경우 REST API 는 412("Precondition Failed") 오류 응답 코드를 보낸다.
  - 제공된 If-Matched 헤더 값 조건이 일치한다면 REST API 는 저장된 리소스의 상태를 갱신하면서 200("OK") 또는 204("No Content") 응답을 준다.
  - 응답에 리소스 상태의 갱신된 표현이 응답에 포함되어 있으면, API는 Last-Modified 와 ETag 헤더 값을 포함해 갱신 여부를 반영한다.

  

> HTTP 는 위의 예제와 같은 방식으로 GET,POST, DELETE 요청 역시 조건부 요청을 지원한다. 이 패턴은 API가 있는 REST API가 클라이언트 들 간의 협업을 지원할 때 주요한 특징이다.

  

## Location 은 새로 생성된 리소스의 URI 를 나타내는 데 사용해야 한다.

Location 응답 헤더에 지정되는 값은 컬렉션 또는 스토어에 성공적으로 리소스를 생성하는 응답이며, 클라이언트의 관심 범위에 있는 리소스를 식별하는 URI 이다.  

REST API 는 Location 헤더를 포함해서 새로 생성된 리소스의 URI를 나타내야 한다. Location 헤더는 202("Accepted") 응답 안에 있는데, 비동기 컨트롤러 리소스의 연관 상태를 클라이언트에 정확히 알려주는데에 사용가능하다.  


## Cache-Control, Expires, Date 응답 헤더는 캐시 사용을 권장하는 데 사용해야 한다.

캐싱은 HTTP 의 매우 유용한 기능이다. 클라이언트의 대기시간을 줄여주고, API 서버의 부하를 감소시켜준다는 장점ㅇ ㅣ있다. 캐시는 어디에나 존재한다. API 의 서버 네트워크나 컨텐츠 전달 네트워크(CDN)에 있을 수도 있다. 또는 클라이언트의 네트워크에도 존재한다.

Cache-Control 헤더를 사용하는 예는 아래와 같다.  

예)  

> Cache-Control : max-age=60, must-revalidate

  

기존의 HTTP 1.0 캐시를 지원하려면, REST API 는 아래의 두가지 헤더를 포함해야 한다.

- Expires 헤더
  - 만료일을 나타내는 헤더
  - API 표현이 만들어진 시간에 갱신 주기가 더해진 날짜이다.
- Date 헤더
  - API 의 응답 시간을 나타낸다.
  - 클라이언트는 이 값을 이용해 Expires 와 Date 헤더 값의 차이값을 구해서 갱신 주기를 계산한다.

예)

> Date : Tue, 15 Nov 1994 08:12:31 GMT
>
> Expires: Thu, 01 Dec 1994 16:00:00 GMT



## Cache-Control, Expires, Pragma 응답 헤더는 캐시 사용을 중지하는 데  사용해야 한다.

- Cache-Control 헤더 값에 `no-cache` , `no-store`  을(를) 사용하면 REST API 응답을 캐시에 저장하지 않는다.
- HTTP 1.0 과 호환하려면 아래의 헤더를 추가해주면 된다.
  - `Pragma: no-cache`
  - `Expires: 0`



## 캐시 기능은 사용해야 한다.

이 책에서는 꼭 필요한 경우가 아니라면 REST API 가 항상 캐시를 사용하는 것은 아니라고 이야기 해주고 있다. 그럼에도 `no-cache` 지시자를 추가하여 캐시를 사용하지 않도록 해야만 하는 경우가 있다면, `max-age` 를 사용해 클라이언트 측에서 갱신에 관계없이 짧은 시간 내에 캐시에 저장된 복사본을 가져올 수 있도록 하라고 권고하고 있다.



## 만기 캐싱 헤더는 200("OK") 응답에 사용해야 한다.



## 커스텀 HTTP 헤더는 HTTP 메서드의 행동을 바꾸는 데 사용해서는 안된다.



