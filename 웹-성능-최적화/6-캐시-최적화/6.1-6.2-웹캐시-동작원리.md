# 웹 캐시 동작 원리 (6.1 ~ 6.2)

캐시에는 여러가지 종류가 있는데, 오늘 정리할 내용은 웹 캐시라 불리는 리버스 프록시 캐시가 HTTP 프로토콜에서 어떤 방식으로 정해진 응답을 내어주는지 정리할 예정이다. 캐시 서버는 HTTP/1.1 규격(RFC2616)을 기반으로 동작한다. 조금 더 자세히 정리해보면, HTTP 헤더에 어떤 값을 지정하는 가에 따라서 캐싱 처리를 어떻게 하는지 어떻게 응답하는지를 정리해볼 것 같다.  

  

## 목차

- [참고자료](#참고자료)
- [캐시](#캐시)
- [캐시 서버의 종류](#캐시-서버의-종류)
- [HTTP 특징](#HTTP-특징)
- [HTTP의 캐시 제어 방식](#HTTP의-캐시-제어-방식)
  - Cache-Control : --- 와 Expires 헤더에 값을 지정할 때 캐시서버와 응답서버, 클라이언트 사이에서 어떤 동작을 하는지 정리
  - [Expire](#expire)
  - [Cache-Control: max-age](cache-control-max-age)
  - [Date, Age 헤더](#date-age-헤더)
  - [Cache-Control: s-maxage](#cache-control-s-maxage)
  - [ETag](#etag)
  - [Cache-Control: public](#cache-control-public)
  - [Cache-Control: private](#cache-control-private)
  - [Cache-Control: no-cache](#cache-control-no-cache)
  - [Cache-Control: no-store](#cache-control-no-store)
- [캐시 유효성 체크](#캐시-유효성-체크)



## 참고자료

[웹 성능 최적화기법](http://www.yes24.com/Product/Goods/96262886)



## 캐시

요청한 데이터의 크기가 크거나 요청수가 많을 경우 항상 같은 결과를 응답하게 되는 결과에 대해서는 캐시에 key, value 형태로 저장해두면, 서버의 부담도 줄어든다는 장점이 있다. 이렇게 서버와 클라이언트 간의 응답 컨텐츠의 사본을 저장하는 공간을 보통 캐시라고 부른다.  

그리고 이러한 캐시를 유지하고 관리해주는 별도의 서버 역시 사용하는 경우가 있다. 이렇게 별도로 캐시를 유지하고 관리해주는 서버를 캐시 서버라고 부른다.  

  

**기본적인 동작 방식**  

- 최초 1회 요청
  - 컨텐츠 요청에 대해서는 캐시 서버에는 내용이 없기 때문에 캐시 서버에 응답의 복사본을 저장해둔다.
- 이후 같은 요청
  - 이때는 응답결과의 복사본을 캐시서버에 저장해두었기 때문에 이 결과를 캐시 서버가 응답해준다.



**최초 1회 요청**  

![이미지](./img/1.png)

  

**최초 2회 요청**  

![이미지](./img/2.png)



## 캐시 서버의 종류

웹 아키텍처에서 주로 사용되는 캐시 또는 캐시 서버들의 종류는 아래와 같은 것들이 있다.

- 브라우저
  - 브라우저 캐시, 로컬 캐시
- 캐시 서버
  - 서버에서 성능향상을 위해 별도로 사용
  - 리버스 프록시 서버에 캐시 기능을 추가해 리버스 캐시 프록시 서버로 사용하기도 하는데 이것을 웹 캐시라고 부른다. (참고 : 우리가 잘 아는 웹 서버가 리버시 프록시 서버에 속함)



ex)

- Apache Traffic Server 
  - 아파치 소프트 웨어 제단에서 제공하는 오픈소스 웹 캐시 서버
- Nginx
  - 이제는 많이 유명해진 Nginx. 로고가 멋있다아...
- Varnish Cache
  - 캐시를 통한 HTTP 가속을 목적으로 개발된 오픈소스 소프트웨어
  - 캐시 및 가속 기능을 제공



## HTTP 특징

HTTP/1.1 부터 명시적으로 캐시를 제어할 수 있는 헤더를 추가했는데 이것이 Cache-Control 헤더이다. HTTP/1.1 이전인 HTTP/1.0 까지는 명시적으로 캐시를 제어하는 기술은 없었고, 언제까지 유효한지(Expire), 만료일 이후 해당 자원의 변경여부를 확인하는 요청/응답 헤더를 정의/기록하는 것에 대한 정의만 있었다.



**HTTP/1.1 이후**   

- Cache-Control 헤더의 도입
- Cache-Control 은 명시적으로 캐시를 제어할 수 있는 헤더
- HTTP/1.1 에서 캐시를 제어하는 목적은 아래의 두가지로 정의된다.
  - 원본 서버로의 요청 수를 최소화
    - 네트워크 왕복 수를 줄여 결과적으로 사용자에 대한 응답 속도를 단축할 수 있다.
  - 완전한 컨텐츠를 응답하지 않아도 된다.
    - 네트워크 대역폭과 리소스 낭비를 줄이고 비용을 효율화

  

**HTTP/1.0 이후**  

- Cache-Control 처럼 명시적으로 캐시를 제어하는 기술은 없었다.
- **Expire** : 언제까지 유효한지 정의 하는 헤더
- 해당 자원의 변경여부를 확인하는 요청/응답 헤더



## HTTP의 캐시 제어 방식

> `Cache-Control : ---` 와 `Expires` 헤더에 값을 지정할 때 캐시서버와 응답서버, 클라이언트 사이에서 어떤 동작을 하는지 정리

브라우저는 프로토콜과 통신규약에 정의된 행동을 헤더에 맞게끔 행동한다. 리버스 프록시 캐시 서버는 웹서버에서 응답헤더에 보내준 헤더를 보고 규약에 맞게끔 행동한다.  

HTTP 라는 프로토콜을 사용할 때 캐시 제어 방식을 클라이언트와 서버에서 적절한 동작을 하도록 약속하려면, **HTTP/1.0, HTTP/1.1 에서 지원하는 헤더 값이 의미하는 바를 잘 알아야 한다.** 이것을 잘 알고 적용해서 브라우저에서의 동작과 리버스 프록시 캐시 서버의 동작을 결정할 수 있다.  

  

### Expire

HTTP/1.0 은 원본 서버에서 Expire, Date 헤더를 함께 응답으로 전달한다. 그리고 이 Expire 와 Date 값을 이용해 응답 컨텐츠가 캐시 서버 내에서 유지될 시간을 지정할 수 있다. 이렇게 캐시 서버 내에서 유지될 기간을 Time To Live(TTL) 이라고 부른다. 이 TTL 은 아래와 같이 **Expire - Date** 으로 구해진다.

- Time To Live (TTL) = Expire_value - Date_value



**참고) Network Time Protocol (NTP) 를 이용한 시계 동기화**  

Network Time Protocol(NTP)는 글로벌 표준 시간 동기화를 위한 매케너즘을 제공하고 있다. 대부분의 서버에서 이것을 구현하고 있다. 서버 - 클라이언트 간 시간 동기화를 위해 꼭 시계 동기화 여부를 확인해야 한다.

  

### Cache-Control: max-age

HTTP/1.1 에서는 Cache-Control: max-age 헤더로 캐시 유지 시간을 정의할 수 있다. Expire 는 만료 날짜를 지정한 반면, max-age 는 얼마나 오래 캐시 내에 유지할 지(유효기간)를 명시적으로 지정하는 헤더이다.   

max-age 만큼의 시간이 경과된 후에 오는 요청에 대해서는 캐시 서버는 원본서버에서 응답 컨텐츠를 가져와 캐시를 갱신하거나, 컨텐츠 변경여부를 원본서버에서 조회해온다.  

  

**HTTP/1.0 버전의 브라우저에서 Cache-Control: max-age 미인식 문제**  

캐시 서버가 HTTP/1.1 을 지원해서 Cache-Control 의 max-age를 사용한다고 하더라도, 브라우저가 HTTP/1.0 버전인 오래된 브라우저일 경우 **Cache-Control: max-age** 는 인식되지 않는다. 이런 이유로 응답이 HTTP/1.0 과 HTTP/1.1 에서 모두 호환 되도록 Expire, Cache-Control: max-age 를 모두 함께 응답으로 내려주는 것이 좋다.  

Expire, Cache-Control: max-age 가 모두 명시된 경우 HTTP/1.1 기반의 캐시 서버는 Cache-Control을 우선적으로 인식하여 응답을 생성해낸다.  

  

### Date, Age 헤더

max-age 헤더값을 기반으로 얼마나 오래 캐시에 머물렀는지 파악하기 위해 전달하는 헤더가 있는데 이것이 Date, Age 헤더이다. HTTP/1.0 에서 Date 헤더를 사용하는 것을 위에서 확인했으니, Date 헤더는 원래 사용하는 것임을 확인했다. 참고로 **Date 헤더**는 **원본 서버 -> 캐시서버**로 전달해주는 응답생성 시각이다.  

캐시 서버 -> 브라우저 로는 Age 헤더에 Date - 응답시간을 담아서 클라이언트에게 전달해준다. 이 age 값을 max-age 값과 비교해 캐시처리된 응답의 만료여부를 판단하는 것 역시 가능하다. 정확한 age를 계산하는 것은 컴퓨팅 시간 등을 고려해야 하는데, 이것이 복밥하여 많은 CDN 업체는 age를 사용하기보다는 자체적인 알고리즘으래 캐시 만료여부를 판단한다.  



### Cache-Control: s-maxage

s-maxage를 이용하면 사용중인 모든 CDN의 캐시 주기를 일괄적으로 설정하거나 변경할 수 있다. 하지만 s-maxage는 표준으로 도입된 지 얼마 되지 않았기 때문에 CDN업체가 이 헤더를 지원하는지를 확인해봐야 한다.



### ETag

ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호이다. 캐시 서버는 ETag로 원본서서의 리소스가 만료된것인지 여부를 확인할 수 있다. ETag는 문자들을 조합해 고유의 문자열을 만드러서 생성하는 문자들의 조합이다. 

보통 우리가 자주 볼수 있는 것은 캐시가 변경되었음을 확인할 수 있도록 이미지/css 파일 등의 정적 파일들에 **시간**이나 **Timestamp** 를 조합한 킷값을 사용하는 경우이다. 반면 ETag의 경우 고유 문자열을 만들어서 캐시의 킷값으로 사용한다.  



### Cache-Control: public

모든 캐시에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있다는 의미의 헤더이다.  



### Cache-Control: private

Cache-Control: private 를 설정한다고 해서 응답에 담긴 개인 정보까지 보호되지는 않는다. public, private 는 응답 메시지를 어디에 캐시할 것인지 지정하기 위해 사용될 뿐 그 자체로 개인정보를 보호하는 장치가 되지는 않는다.  

TODO : 더 자세한 의미 찾아보기 (MDN 등등)  



### Cache-Control: no-cache

Cache-Control: no-cache 는 아래의 두가지 경우에 따라 다르게 정리하게 될 수 밖에 없다.

- 요청헤더에 Cache-Control: no-cache 를 담아 요청하는 경우
- 응답 헤더에 Cache-Control: no-cache 를 담아 응답하는 경우



**요청헤더에 Cache-Control: no-cache 를 담아 요청하는 경우**  

Cache-Control: no-cache 를 헤더에 담아 요청하는 경우 캐시된 응답을 받는 것이 아니라 매번 새로운 컨텐츠를 응답으로 전달받는다. 즉, Cache-Control: no-cache 를 요청 헤더로 해서 클라이언트가 캐시 서버에 요청을 하면 캐시 서버는 항상 웹 서버에서 원본 컨텐츠를 가져온다.  

  

> **참고)**
>
> max-age=0 을 요청 헤더에 사용하는 것과 비슷한 동작을 하는 것으로 착각하기 쉽다. max-age=0 는 유효기간인 0 이 지났다고 해서 단순히 응답서버로부터 컨텐츠를 새로 받아오지는 않는다.  
>
> 캐시서버가 max-age=0을 요청 헤더로 하는 요청을 받았을 때 캐시 서버에 조건부 요청을 보내 응답 메시지가 변경되었는지 확인한다. (예를 들면, css 등에 타임스탬프 등을 지정해서 버저닝을 해놓은 경우를 생각해보자. 이런 값이 변경되었는지를 확인해봤는데, 해당 컨텐츠의 킷값으로 지정한 문자열을 킷값으로 하는 리소스가 지금 캐시 서버에 존재한다면, 새로운 컨텐츠를 받아오지 않고 캐시된 결과값을 리턴한다.)  

  

**응답헤더에 Cache-Control: no-cache 를 담아 응답하는 경우**

응답헤더에 Cache-Control: no-cache를 담아 응답하는 경우는 요청헤더에 담을 때와는 다르게 max-age=0 과 유사한 동작을 한다. **응답캐시 사본을 클라이언트에게 전달하기 전에 먼저 응답서버를 조회해서 변경되었는지를 먼저 조회한다.** 이렇게 조회한 결괏값으로 **변경되었음을 감지하면 새로 받아오고**, **변경되지 않았다면 캐시 사본을 클라이언트에게 전달**한다.  

  

조금 더 자세히 설명해보면 ... 캐시 서버에는 두 번째 이후의 응답 사본이 캐시로 저장되어 있는데, 이 응답 사본의 헤더에 max-age=0 이 있다면, 캐시 응답 사본을 클라이언트에게 전달하기 전에 먼저 응답 서버의 해당 컨텐츠가 변경되었는지를 먼저 조회한다. 그리고 변경되지 않았다면 캐시 응답 사본을 그대로 클라이언트에게 전달한다. 만약 변경되었다면 캐시 응답 사본을 새로고침하고 새로고침한 컨텐츠를 전달한다.  



동작 절차를 예를 들어서 정리해보면 아래와 같다.  



- 첫번째 요청
  - 클라이언트(브라우저, 웹뷰 등)가 응답서버로 요청을 한다.
  - 응답 서버로 한 요청에 들르기 전에 캐시서버를 들른다.
  - 캐시 서버에서는 해당 컨텐츠가 저장되어있지 않음을 확인하고 원본 서버로부터 컨텐츠를 가져와 저장소에 저장해둔다.
  - 캐시 서버는 이 컨텐츠를 클라이언트에게 응답으로 전달해준다.
- 두번째 요청
  - 클라이언트(브라우저, 웹뷰 등)가 응답서버로 또 요청을 한다.
  - 응답 서버로 한 요청에 들르기 전에 캐시서버를 들른다. 
  - 캐시 서버에 해당 컨텐츠가 저장되어 있음을 확인했다.
  - 캐시 서버는 해당 컨텐츠가 응답 서버에서 변경되었는지 조회해본다.
  - 응답 서버에서 해당 컨텐츠가 변경되었다면, 캐시된 응답 사본을 새로고침한다.

  

만약 원본서버의 응답에서 특정항목은 캐시하고 싶지 않을 때는 지시자 옆에 캐시하지 않을 헤더들을 나열해주면 된다. 예를 들면 no-cache="Accept-Range"라고 응답에 기술하면 된다. 이렇게 하면 서버는 응답을 캐시하되 Accept-Range 헤더를 캐시하지 않는다.  

  

### Cache-Control: no-store

no-store 는 응답메시지가 캐시 저장소에 저장되는 것을 금지한다. no-store의 목적은 캐시 데이터의  예기치 않은 유출을 방지하는 것이 목적이다.  

  

**no-cache 와의 비교**  

no-cache 는 응답을 항상 최신 상태로 유지하도록 지시한다. 하지만 no-store처럼 저장소에 저장되는 것을 막지는 않는다. no-store와 no-cache가 비슷하게 생겨서 혼동하기 쉬우니 유의해야 할 것 같다.



## 캐시 유효성 체크



