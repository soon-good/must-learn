# 웹 캐시 동작 원리 (6.1 ~ 6.2)

캐시에는 여러가지 종류가 있는데, 오늘 정리할 내용은 웹 캐시라 불리는 리버스 프록시 캐시가 HTTP 프로토콜에서 어떤 방식으로 정해진 응답을 내어주는지 정리할 예정이다. 캐시 서버는 HTTP/1.1 규격(RFC2616)을 기반으로 동작한다. 조금 더 자세히 정리해보면, HTTP 헤더에 어떤 값을 지정하는 가에 따라서 캐싱 처리를 어떻게 하는지 어떻게 응답하는지를 정리해볼 것 같다.

## 목차

- [참고자료](#참고자료)
- [캐시](#캐시)
- [캐시 서버의 종류](#캐시-서버의-종류)
- [HTTP 특징](#HTTP-특징)
- [HTTP의 캐시 제어 방식](#HTTP의-캐시-제어-방식)
  - [Expire](#Expire)
  - [Cache-Control: max-age](Cache-Control-max-age)
  - [Date, Age 헤더](#Date,-Age-헤더)
  - [Cache-Control: s-maxage](Cache-Control-s-maxage)
  - [ETag](#ETag)
  - [Cache-Control: public](Cache-Control-public)
  - [Cache-Control: private](Cache-Control-private)



## 참고자료

[웹 성능 최적화기법](http://www.yes24.com/Product/Goods/96262886)



## 캐시

요청한 데이터의 크기가 크거나 요청수가 많을 경우 항상 같은 결과를 응답하게 되는 결과에 대해서는 캐시에 key, value 형태로 저장해두면, 서버의 부담도 줄어든다는 장점이 있다. 이렇게 서버와 클라이언트 간의 응답 컨텐츠의 사본을 저장하는 공간을 보통 캐시라고 부른다.  

그리고 이러한 캐시를 유지하고 관리해주는 별도의 서버 역시 사용하는 경우가 있다. 이렇게 별도로 캐시를 유지하고 관리해주는 서버를 캐시 서버라고 부른다.  

  

**기본적인 동작 방식**  

- 최초 1회 요청
  - 컨텐츠 요청에 대해서는 캐시 서버에는 내용이 없기 때문에 캐시 서버에 응답의 복사본을 저장해둔다.
- 이후 같은 요청
  - 이때는 응답결과의 복사본을 캐시서버에 저장해두었기 때문에 이 결과를 캐시 서버가 응답해준다.



**최초 1회 요청**  

![이미지](./img/1.png)

  

**최초 2회 요청**  

![이미지](./img/2.png)



## 캐시 서버의 종류

웹 아키텍처에서 주로 사용되는 캐시 또는 캐시 서버들의 종류는 아래와 같은 것들이 있다.

- 브라우저
  - 브라우저 캐시, 로컬 캐시
- 캐시 서버
  - 서버에서 성능향상을 위해 별도로 사용
  - 리버스 프록시 서버에 캐시 기능을 추가해 리버스 캐시 프록시 서버로 사용하기도 하는데 이것을 웹 캐시라고 부른다. (참고 : 우리가 잘 아는 웹 서버가 리버시 프록시 서버에 속함)



ex)

- Apache Traffic Server 
  - 아파치 소프트 웨어 제단에서 제공하는 오픈소스 웹 캐시 서버
- Nginx
  - 이제는 많이 유명해진 Nginx. 로고가 멋있다아...
- Varnish Cache
  - 캐시를 통한 HTTP 가속을 목적으로 개발된 오픈소스 소프트웨어
  - 캐시 및 가속 기능을 제공



## HTTP 특징

HTTP/1.1 부터 명시적으로 캐시를 제어할 수 있는 헤더를 추가했는데 이것이 Cache-Control 헤더이다. HTTP/1.1 이전인 HTTP/1.0 까지는 명시적으로 캐시를 제어하는 기술은 없었고, 언제까지 유효한지(Expire), 만료일 이후 해당 자원의 변경여부를 확인하는 요청/응답 헤더를 정의/기록하는 것에 대한 정의만 있었다.



**HTTP/1.1 이후**   

- Cache-Control 헤더의 도입
- Cache-Control 은 명시적으로 캐시를 제어할 수 있는 헤더
- HTTP/1.1 에서 캐시를 제어하는 목적은 아래의 두가지로 정의된다.
  - 원본 서버로의 요청 수를 최소화
    - 네트워크 왕복 수를 줄여 결과적으로 사용자에 대한 응답 속도를 단축할 수 있다.
  - 완전한 컨텐츠를 응답하지 않아도 된다.
    - 네트워크 대역폭과 리소스 낭비를 줄이고 비용을 효율화

  

**HTTP/1.0 이후**  

- Cache-Control 처럼 명시적으로 캐시를 제어하는 기술은 없었다.
- **Expire** : 언제까지 유효한지 정의 하는 헤더
- 해당 자원의 변경여부를 확인하는 요청/응답 헤더



## HTTP의 캐시 제어 방식

TODO 정리 필요

### Expire

HTTP/1.0 은 원본 서버에서 Expire, Date 헤더를 함께 응답으로 전달한다. 그리고 이 Expire 와 Date 값을 이용해 응답 컨텐츠가 캐시 서버 내에서 유지될 시간을 지정할 수 있다. 이렇게 캐시 서버 내에서 유지될 기간을 Time To Live(TTL) 이라고 부른다. 이 TTL 은 아래와 같이 **Expire - Date** 으로 구해진다.

- Time To Live (TTL) = Expire_value - Date_value



**참고) Network Time Protocol (NTP) 를 이용한 시계 동기화**  

Network Time Protocol(NTP)는 글로벌 표준 시간 동기화를 위한 매케너즘을 제공하고 있다. 대부분의 서버에서 이것을 구현하고 있다. 서버 - 클라이언트 간 시간 동기화를 위해 꼭 시계 동기화 여부를 확인해야 한다.

  

### Cache-Control: max-age

HTTP/1.1 에서는 Cache-Control: max-age 헤더로 캐시 유지 시간을 정의할 수 있다. Expire 는 만료 날짜를 지정한 반면, max-age 는 얼마나 오래 캐시 내에 유지할 지(유효기간)를 명시적으로 지정하는 헤더이다.   

max-age 만큼의 시간이 경과된 후에 오는 요청에 대해서는 캐시 서버는 원본서버에서 응답 컨텐츠를 가져와 캐시를 갱신하거나, 컨텐츠 변경여부를 원본서버에서 조회해온다.



**HTTP/1.0 버전의 브라우저에서 Cache-Control: max-age 미인식 문제**  

캐시 서버가 HTTP/1.1 을 지원해서 Cache-Control 의 max-age를 사용한다고 하더라도, 브라우저가 HTTP/1.0 버전인 오래된 브라우저일 경우 **Cache-Control: max-age** 는 인식되지 않는다. 이런 이유로 응답이 HTTP/1.0 과 HTTP/1.1 에서 모두 호환 되도록 Expire, Cache-Control: max-age 를 모두 함께 응답으로 내려주는 것이 좋다.  

Expire, Cache-Control: max-age 가 모두 명시된 경우 HTTP/1.1 기반의 캐시 서버는 Cache-Control을 우선적으로 인식하여 응답을 생성해낸다.  



### Date, Age 헤더

max-age 헤더값을 기반으로 얼마나 오래 캐시에 머물렀는지 파악하기 위해 전달하는 헤더가 있는데 이것이 Date, Age 헤더이다. HTTP/1.0 에서 Date 헤더를 사용하는 것을 위에서 확인했으니, Date 헤더는 원래 사용하는 것임을 확인했다. 참고로 **Date 헤더**는 **원본 서버 -> 캐시서버**로 전달해주는 응답생성 시각이다.  

캐시 서버 -> 브라우저 로는 Age 헤더에 Date - 응답시간을 담아서 클라이언트에게 전달해준다. 이 age 값을 max-age 값과 비교해 캐시처리된 응답의 만료여부를 판단하는 것 역시 가능하다. 정확한 age를 계산하는 것은 컴퓨팅 시간 등을 고려해야 하는데, 이것이 복밥하여 많은 CDN 업체는 age를 사용하기보다는 자체적인 알고리즘으래 캐시 만료여부를 판단한다.  
  


### Cache-Control: s-maxage

s-maxage를 이용하면 사용중인 모든 CDN의 캐시 주기를 일괄적으로 설정하거나 변경할 수 있다. 하지만 s-maxage는 표준으로 도입된 지 얼마 되지 않았기 때문에 CDN업체가 이 헤더를 지원하는지를 확인해봐야 한다.



### ETag

ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호이다. 캐시 서버는 ETag로 원본서서의 리소스가 만료된것인지 여부를 확인할 수 있다. ETag는 문자들을 조합해 고유의 문자열을 만드러서 생성하는 문자들의 조합이다. 보통 시간이나 Timestamp 와 같은 값들을 지정하여 캐시가 변경되었음을 알려주는 편이지만, ETag를 사용해 고유 문자열을 만들어 캐시의 킷값을 가지고 있을 수도 있다.  
  


### Cache-Control: public

모든 캐시에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있다는 의미의 헤더이다.  
  


### Cache-Control: private

Cache-Control: private 를 설정한다고 해서 응답에 담긴 개인 정보까지 보호되지는 않는다. public, private 는 응답 메시지를 어디에 캐시할 것인지 지정하기 위해 사용될 뿐 그 자체로 개인정보를 보호하는 장치가 되지는 않는다.  

TODO : 더 자세한 의미 찾아보기 (MDN 등등)  
  


### Cache-Control: no-cache



### Cache-Control: no-store

