# HTTP/2의 최적화 기술

주 교재는 [웹 성능 최적화기법](http://www.yes24.com/Product/Goods/96262886) 을 참고해서 요약했다. 저자 분께서 좋은 책을 써주셔서 너무 감사한 마음으로 공부했다. 하지만, 책을 읽고 막상 요약할 때가 되니 이 용어가 이 뜻인지 아니면 그 다음 페이지에 있는 이 뜻인지 애매할 때가 많아서 정리할 때 조금 혼동된 적이 많았던 것 같다. 굉장히 고생해서 정리했던 것 같다.    

  

## 목차

- [참고자료](#참고자료)
- [OVERVIEW](#OVERVIEW)
- [HTTP/2의 프레임, 메시지, 스트림](#HTTP/2의 프레임, 메시지, 스트림)
- [멀티플렉싱](#멀티플렉싱)
- [헤더압축](#헤더압축)
- [서버푸시](#서버푸시)



## 참고자료

- 주교재
  
  - [웹 성능 최적화기법](http://www.yes24.com/Product/Goods/96262886)  
- 참고한 자료들
  - [HTTP/2에서 Frame, Stream의 의미](https://brunch.co.kr/@sangjinkang/3)

  

## OVERVIEW

- HTTP/1.1 을 개선한 웹 프로토콜을 만들기 위해 구글이 시작한 SPDY 프로젝트가 모태이다.  
- SPDY 프로젝트는 HTTP/1.1 과 HTTP/2 의 중간단계 프로토콜이다.
- HTTP/1.1 프로토콜은 헤더와 페이로드가 텍스트 기반의 메시지 형태였다.  
- HTTP/2 에서는 이것을 경량화 하기 위해 이진 포맷(binary format)을 사용하게 되었다.
- 멀티플렉싱, 스트림 우선순위 설정, 헤더압축(HPACK), 서버 푸시 같은 새로운 기능들이 HTTP/2 프로토콜에 추가되었다.



## HTTP/2의 프레임, 메시지, 스트림

**프레임**  

HTTP/2 통신에서 가장 작은 단위의 정보 단위이다.   

헤더프레임 또는 데이터프레임으로 구분될 수 있다.  

  

**메시지**  

다수의 프레임이 모여서 이뤄지는 단위이다.  

요청/응답을 보내는 단위이다.(HTTP/1.1 역시 요청/응답을 보내는 단위는 메시지 이다.) 



**스트림**  

클라이언트와 서버 사이에 맺어진 연결을 통해 양방향으로 주고 받는 하나 또는 복수의 메시지이다.  

프레임과 메시지가 모두 스트림에 포함될 수 있다.  

**HTTP/1.1** 에서 요청과 응답은 하나의 메시지가 각 오브젝트의 요청과 응답을 담당했다. 즉, HTTP/1.1 은 메시지 기반의 통신을 했다. **즉, 요청과 응답이 메시지라는 단위로 완벽하게 구분되어 있었다.**   

하지만 **HTTP/2** 에서는 스트림이라는 단위를 통해 요청과 응답을 하나의 단위로 묶을 수 있게 되었다.  

스트림을 요청,응답할 때 요청 시에는 고유 번호를 부여하여 요청을 스트림으로 보내고, 이 요청에 대한 응답은 요청스트림과 같은 스트림 번호를 가진다. 이 때 클라이언트는 응답 스트림의 번호를 통해 어떤 요청에 대한 응답인지 구분하게 된다.  



## 멀티플렉싱

멀티플렉싱은 HTTP/1.1 의 파이프라이닝 기능을 개선한 HTTP/2 에서 지원하는 기능이다.  

서버에서 만들어지는 응답 프레임들을 만들어지면 만들어지는 대로 요청순서에 상관없이 클라이언트에게 전달하는 기능이다. 이렇게 하나의 TCP 커넥션 상에서 여러개의 클라이언트 요청과 서버의 응답이 비동기 방식으로 이루어지는 기술을 **멀티플렉싱**이라고 한다. 그리고 이렇게 전달된 응답을 클라이언트 측에서 조립해 완전한 형태의 데이터를 만든다.    



**참고) HTTP/1.1의 파이프라이닝 기능**  

파이프라이닝은 요청과 응답을 반복하는 HTTP를 개선하기 위해 먼저 요청한 컨텐츠가 전달이 완료되지 않아도 다음 컨텐츠를 미리 처리하면서 웹 성능을 더욱 빠르게 만들기 위해 개발된 기능이다. 하지만, 여전히 선입 선출 방식이었다. 이런 이유로 먼저 요청된 컨텐츠의 전달이 완료될 때 까지 그 다음의 컨텐츠들은 대기상태로 있어야 했다. 이런 증상으로 인해 HOL 문제가 발생했는데, HTTP/2의 멀티플렉싱 기술 덕에 컨텐츠 전달 시의 병목현상을 어느 정도는 해결할 수 있게 되었다.  



## 헤더압축

**HTTP/1.1 에서의 Content-Encoding 헤더의 단점**  

HTTP/1.1버전의 Content-Encoding 헤더는 HTTP 페이로드를 서버에서 압축했다. 클라이언트 측에서는 실제로 전달받게될 크기보다 압축된 사이즈를 받게 되므로 효율적이지만, 헤더는 압축되지 않는다는 단점이 있었다. 



**HTTP/2 의 가상 테이블**  

HTTP/2 에서는 클라이언트와 서버 사이에 가상 테이블을 만들어서 동일하고 중복되는 헤더 값들을 테이블에 저장하고 참고하는 방식을 사용하여 중복 전달을 제거했다.  

가상 테이블은 **정적테이블, 동적 테이블**로 구성될 수 있다.  

- 정적 테이블
  - 미리 정의된 자주 사용되는 헤더 필드를 저장하고 있는다
- 동적 테이블
  - 클라이언트와 서버 사이의 통신 시에 주고받은 값들을 업데이트 한다.
  - 각 테이블에는 숫자로 표기된 인덱스가 있는데 동일한 값을 전달 할 때는 중복되었던 값을 보내지 않고, 그 값을 가지는 인덱스 번호로 대체하여 보낸다.



**HPACK**  

HPACK은 헤더 압축 알고리즘이다. 허프만 알고리즘(Huffman algorithm)을 활용해 헤더를 압축하는 HTTP/2에서 도입된 헤더 압축 방식이다. 이 HPACK 알고리즘을 통해 헤더를 압축해 조금 더 경량의 데이터를 주고 받을 수 있게 되었다.  



## 서버푸시

TODO!!