# On-Heap 메모리와 Off-Heap 메모리 비교

EhCache 에 관련된 자료를 찾다보니 On Heap, Off Heap 에 관련된 자료를 접했다. EhCache 말고도 더 좋은 Off Heap 을 다루는 것이 있는지는 찾아봐야 알 것 같다. <br>

이것 저것 보다보니 좀 짱인듯? 하는 생각이 들었지만, <br>

- "EhCache를 사용하는 것이 만능은 아니다"
- "EhCache 로 다 해결되는 것은 아니다." 

하는 생각으로 나 자신을 강력하게 세뇌하고 있다.<br>

캐시에 저장해야 하는 데이터의 크기가 상당히 커져서 캐시 미적중 시 데이터 인출에 걸리는 시간이 어느정도 커지게 되면 그때부터는 EhCache같은 로컬 애플리케이션 레벨의 캐시보다는 Spark, Hadoop 등을 도입하는 것을 고려해야할 지도 모른다는 생각은 들었다. 이럴 때는 스프링 레벨에서 처리하는 것 보다는 Off Heap 을 전담하는 컨테이너인 카프카, 하둡, 스파크를 사용하는 것을 고려하게 될 것 같다.(나도 모르게 또 off heap 캐시가 짱이다 하는 생각으로 이런 상상을 해버린것 같다.)<br>



## 참고자료

- [BigMemory (Off-Heap Store)](https://www.ehcache.org/documentation/2.8/get-started/storage-options.html)
- [Stackoverflow - on heap, off heap](https://stackoverflow.com/questions/6091615/difference-between-on-heap-and-off-heap)
- [Java - On-heap과 Off-heap](https://soft.plusblog.co.kr/163)
- [가상메모리 - 운영체제](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-15.-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC)
- [스파크 2.0 의 성능개선 - 직렬화, off-heap, 옵티마이저](https://118k.tistory.com/762) 
- [Kafka off heap memory leak](https://stackoverflow.com/questions/45813477/kafka-off-heap-memory-leak)

<br>

## 힙 메모리

참고로, heap 이라는 메모리공간은 Java 언어에서만 사용하는 용어는 아니다. 대학생 시절에 c++ 언어가 유행했었는데, 이때 c++ 관련 언어강의에서도 heap 메모리 이야기를 했었다. stack 메모리 공간은 보통 전역 변수, 지역변수, 함수 등 정적인 데이터를 가지고 있지만, heap 메모리 영역은 동적 메모리 생성(new 연산, malloc 등)을 통해 할당되는 공간으로 알고 있다. (ex. 재귀함수를 무한히 호출해보면  stack overflow 가 발생한다.)<br>

이 당시 c, c++ 은 보통 애플리케이션 또는 게임 개발같은 클라이언트 개발이 많았었다. 이런 이유로 heap 메모리가 stack 메모리보다 크다는 것을 장점으로 이야기 했었다. 하지만 모바일기기와 각종 통신 시스템이 좋아지면서 2010년대 후반~ 2020년대에 들어서면서 트래픽과 처리량이 많은 시스템이 많아졌다. <br>

이런 이유로 heap 메모리만으로는 부하를 모두 처리할 수 없고, 수직적인 스케일링은 어느 정도 한계치에 도달하기 시작했다. 그래서인지 카프카, 스파크, 하둡과 같은 처리 시스템이 생겼다. 이것들은 모두 하드 디스크에 다시 읽어들이기 효율적인 구조로 데이터를 저장한다고 들었다. 주로 페이지 캐시를 사용한다는 이야기를 많이 들었다.<br>

운영체제 수업시간에 수도 없이 들은 용어가 페이지였지만, 공부에 관심이 없어서 지금은 기억이 안나긴 한다. 불량학생이었기 때문에 모든 내용은 기억이 안나지만... 페이지 캐시를 사용한다는 것은 하드 디스크의 일부를 RAM 메모리에 매핑해서 사용하는 것을 의미하는 것으로 알고 있다.<br>

페이지 캐시는 하드 디스크 IO 처리 속도 보다는 빠르지만 RAM 메모리 IO 처리 속도 보다는 조금 느린 중간 속도의 처리 속도를 가지고 있다.<br>



## On Heap Store

보통 new 연산 등을 이용해 생성된 메모리는 heap 이라는 공간에 저장된다. C, C++ 는 free, 소멸자 등을 통해 이렇게 생성된 메모리를 해제한다. 그래서 직접 메모리 누수를 해결하는 경우가 많다. <br>

Java 에서는 이렇게 new 연산을 통해 동적 생성된 객체/변수 들이 저장되는 곳을 On Heap Store 라고 부른다. 그리고 Java 는 가비지 컬렉터(Garbage Collector)가 사용되지 않는 메모리를 JVM 내의 알고리즘으로 회수한다.<br>

하지만, 가비지 컬렉터는 만능이 아니다. 엄청난 트래픽을 처리하는 시스템을 Java 로 구현했을 경우, 초당 생성되는 컬렉션의 수가 어마 무시하게 많아질 경우 heap 메모리를 더 많이 사용할 수록 RAM 메모리용량을 늘려야 하기에 서버증설비용이 계속 증가하게 된다. 즉, 운영비용이 늘어나게 된다.<br>



## Off Heap Store

위와 같이 엄청난 트래픽을 처리하는데, RAM 메모리의 물리적인 크기가 요청량에 대응하지 못할 경우, 또는 가비지 컬렉터의 메모리 관리 능력이 요청량을 따라가지 못하는 경우, RAM 보다는 비교적 가격이 매우 저렴한 하드 Disk 공간을 어느 정도 이용하는게 좋은 선택이 된다. 즉, 디스크의 일부분을 메모리의 일정영역과 매핑해서 사용하는 알고리즘을 사용하는 경우가 있다. <br>

운영체제 시간에 배운 가상메모리라는 개념인데, 자세한 내용은  [가상메모리 - 운영체제](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-15.-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC)를 참고하자. 이렇게 Java 에서는 가상메모리를 사용하는 기법을 Off Heap Store 라고 하는 듯 하다. Java 에서는 nio 를 통해 Off Heap Store 를 사용할 수 있도록 해준다. Direct Byte Buffer 를 이용해 생성한 변수인 버퍼데이터는 가비지 컬렉터가 관리하는 것이 아닌 Off Heap Store 에 저장된다.<br>

대용량 처리에 Off Heap Store 를 사용하는 것을 어느 정도 큰 시스템에서 성능을 내도록 하는 것은 MIT, 스탠퍼드 이런 곳의 공과대학 대학원생 이런 분들이 페이스북, 링크드인 이런 곳에서 일하면서 내는 논문들의 연구 결과로 제품을 출시하는 것들이 대용량 처리에 페이지 캐시를 사용하는 하둡, 카프카 이런 것이기에 보통 일반인들이 구현하기 쉬운 수준은 아닐 수 있겠다는 생각 역시 들었다.<br>

Off Heap Store 에 데이터를 저장하기 위해서는 직렬화를 해야 한다. 이렇게 직렬화를 하는 비용이 발생하기에 되도록 Off Heap Store 에 저장하는 객체는 사이즈가 크고 오랫동안 메모리에 살아있는 객체이면서, 네이티브 I/O 연산의 대상이 되는 객체를 사용하는 것이 권장된다.<br>

On Heap Store 에 저장되는 모든 것들을 Off Heap Store 에 옮길 수는 없다. 하지만 On Heap Store 에서 사용하는 것들 중 필요한 것들을 깐깐하게 잘 따져서 Off Heap Store로 옮기는 것도 좋은 방법 중 하나인 것 같다.<br>

