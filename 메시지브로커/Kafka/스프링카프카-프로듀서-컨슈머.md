# 스프링 카프카 프로듀서 컨슈머




## 프로듀서

## application.yml

아래는 application.yml 에 설정할 수 있는 프로듀서 옵션 값이다. (application.yml 파일에 설정한 프로듀서에 대한 옵션 값은 애플리케이션이 실행될 때 자동으로 오버라이드 되어 설정된다) <br>

```properties
spring.kafka.producer.acks
spring.kafka.producer.batch-size
spring.kafka.producer.bootstrap-servers
spring.kafka.producer.buffer-memory
spring.kafka.producer.client-id
spring.kafka.producer.compression-type
spring.kafka.producer.key-serializer
spring.kafka.producer.properties.*
spring.kafka.producer.retries
spring.kafka.producer.transaction-id-prefix
spring.kafka.producer.value-serializer
```

스프링 카프카가 아닌 일반 카프카 라이브러리를 자바의 기본 기능만을 이용해서 구현할 때는 반드시 `bootstrap-servers`, `key-serializer`, `value-serializer`를 선언하지 않으면 ConfigException 이 발생한다. 이 3개는 필수 옵션이기 때문이다.<br>

스프링 카프카에서 프로듀서를 사용할 경우는 필수 옵션이 없다. 만약  `bootstrap-servers`, `key-serializer`, `value-serializer` 에 값을 설정하지 않으면 localhost:9092, StringSerializer 로 각각 기본값이 자동 설정된다.<br>

아래는 acks 옵션을 all 로 설정하고 host를 직접 지정한 경우의 application.yml 파일이다.

```yaml
spring:
  kafka:
    producer:
      bootstrap-servers: ec2-gosgjung-hotmail:9092
      acks: all
```



## 프로듀서

### 첫번째 프로듀서 애플리케이션

가장 기본으로 제공되는 것을 커스터마이징하지 않고 단순 동작만을 확인하기 위한 예제를 작성해보면 아래와 같다.

```java
package io.study.springkafka.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

@Component
public class SampleKafkaProducerRunner implements CommandLineRunner {

	@Autowired
	private KafkaTemplate<Integer, String> template;

	@Override
	public void run(String... args) throws Exception {
		for(int i=0; i<10; i++){
			template.send("spring-kafka-test", String.format("테스트메시지#%s", i));
		}
		System.exit(0);
	}
}
```

위의 코드를 인텔리제이에서 Run Application 한 후에 카프카가 설치된 EC2 또는 로컬 개발 PC에서 메시지를 확인해보면 아래와 같다.<br>

아래는 로컬 개발 PC에서 카프카 컨슈머 CLI를 실행시킨 결과다.<br>

**컨슈머 CLI로 결과 확인해보기**<br>

```bash
$ bin/kafka-console-consumer.sh --bootstrap-server ec2-gosgjung-hotmail:9092 --topic spring-kafka-test --property print.key=true --property key.separator="-" --from-beginning


null-테스트메시지#0
null-테스트메시지#1
null-테스트메시지#2
null-테스트메시지#3
null-테스트메시지#4
null-테스트메시지#5
null-테스트메시지#6
null-테스트메시지#7
null-테스트메시지#8
null-테스트메시지#9
```

<br>

### 프로듀서 - kafkaTemplate.send() 메서드의 다양한 형태

스프링 카프카에서 제공해주는 KafkaTemplate 에서 제공해주는 send 메세지는 아래와 같은 종류가 있다.

- send(String topic, V data)
  - 토픽에 데이터 data 를 전송한다.
- send(String topic, Integer partition, K key, V data)
  - 메시지 키, 메시지 값을 포함하는 레코드를 특정 토픽의 특정 파티션으로 전달
- send(String topic, Integer partition, Long timestamp, K key, V data)
  - 메시지 키, 메시지 값, 타임스템프를 포함하는 레코드를 특정 토픽의 특정 파티션으로 전달
- send(ProducerRecord\<K,V\> record)
  - 프로듀서 레코드(ProducerRecord) 객체를 전송

<br>

## 커스텀 카프카 템플릿 정의

하나의 스프링 카프카 애플리케이션 내부에 다양한 종류의 카프카 프로듀서 인스턴스를 생성하고 싶을 경우에 사용하는 방식이다. 예를 들면 클러스터 A 로 데이터를 전송하는 카프카 프로듀서, 클러스터 B로 데이터를 전송하는 카프카 프로듀서를 애플리케이션에서 KafkaTemplate 객체로 사용하고 싶을 경우에 각각의 설정을 다르게 해서 각기 다른 빈으로 등록해 사용할 수 있다.

```java
```




## 컨슈머

카프카 클라이언트 라이브러리로 컨슈머를 직접 구현할 때 가장 어려운 부분은 커밋을 구현하는 부분이다. 카프카 컨슈머에서 직접 커밋을 구현할 때는 오토 커밋, 동기 커밋, 비동기 커밋으로 크게 세가지로 나뉘어진다. 하지만, 실제 운영환경에서는 다양한 종류의 커밋을 구현해서 사용해야 한다. 예를 들면 특정 타이밍마다 커밋을 하거나 레코드 갯수에 따라 커밋을 하는 규칙을 적용할 때는 로직을 새로 작성해야 한다.<br>

스프링 카프카는 사용자가 사용할 만한 커밋의 종류를 7가지로 세분화하고 미리 로직을 만들어놓았다. 사용자는 각 커밋 종류를 살펴보고 어떤 커밋 방식을 사용할지 정하면 된다. 스프링 카프카에서는 커밋이라는 용어를 `AckMode` 라고 부른다. 이 점에 유의해야 한다.<br>

프로듀서에서 사용하는 옵션 `acks` 과 컨슈머가 사용하는 옵션인 `AckMode` 는 둘 다 Acknowledgement 를 연상시키기에 혼동하기 쉽다. 프로듀서에서 사용하는 `acks` 와 컨슈머에서 사용하는 `AckMode` 는 명백히 다른 옵션이어서 `acks` 와 `AckMode` 를 혼동하지 않아야 한다. 스프링 카프카 컨슈머의 `AckMode` 의 기본 설정 값은 `BATCH` 다. 컨슈머의 `enable.auto.commit` 옵션의 기본 값은 false 로 지정된다.





| AckMode         | 용도 및 역할, 기본값                                         |
| --------------- | ------------------------------------------------------------ |
| RECORD          | 레코드 단위로 처리(프로세싱) 후 커밋                         |
| BATCH           | poll() 메서드로 호출된 레코드가 모두 처리된 이후에 커밋. 스프링 카프카 컨슈머의 AckMode 기본값 |
| TIME            | 특정 시간 이후에 커밋. 이 옵션을 사용할 경우, 시간 간격을 의미하는 AckTime 옵션을 지정해야 함 |
| COUNT           | 특정 갯수만큼 레코드가 처리된 이후에 커밋. 이 옵션을 사용할 경우, 레코드 갯수를 선언하는 AckCount 옵션을 지정해야 함 |
| COUNT_TIME      | TIME, COUNT 옵션 중 맞는 조건이 둘중에 하나라도 있을 경우 커밋을 수행 |
| MANUAL          | Acknowledgement.acknowledge() 메서드가 호출되면 다음번 poll() 에서 커밋을 한다. 매번 acknowledge() 메서드를 호출하면 BATCH 옵션과 동일하게 동작한다. 이 옵션을 사용할 경우 AcknowledgingMessageListener 또는 BatchAcknowledgingMessageListener 를 리스너로 사용해야 한다. |
| MANUAL_IMMEDATE | Acknwledgement.acknowledge() 메서드를 호출한 즉시 커밋한다. 이 옵션을 사용할 경우 AcknowledgingMessageListener 또는 BatchAcknowledgingMessageListener 를 리스너로 사용해야 한다. |









