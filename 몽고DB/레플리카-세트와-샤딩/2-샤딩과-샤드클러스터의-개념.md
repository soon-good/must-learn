# 샤딩과 샤드클러스터의 개념

샤딩은 대규모의 데이터 세트를 작고 관리하기 쉬운 조각으로 분할하는 과정이다. 내 경우는 엘라스틱 서치를 혼자서 공부해보다가 샤딩이라는 개념을 처음 접했었다. 샤딩은 데이터의 구간을 나누어서 저장하는 것을 의미한다. 이렇게 샤딩된 데이터베이스는 레플리카 셋을 통해 복제된 세트를 구성한 후에 클러스터화 하는 것 역시 가능하다. 클러스터화 하게 될때는 샤드 서버, Config 서버, mongos 라우터 등의 개념으로 구성되는데 여기에 대해서도 정리할 예정이다.<br>

mongos, mongod 라는 용어가 자주 나오는데, 여기에 대해서도 정리한다. 이 외에 샤딩에서 사용되는 여러가지 운영상의 용어에 대해서도 정리한다. 저장소 분산, 부하분산, 수직적 스케일링, 수평적 스케일링, 구역지정 등등이다.<br>

MongoDB의 샤딩은 애플리케이션의 확장을 도울 수 있지만, 관리에 어느 정도의 시간적, 인적 비용을 들여야 한다. 때문에 비용적 측면을 고려해서, 꼭 필요한 경우라면 도입하는게 낫겠지만, 샤딩을 하지 않아도 되는 경우라면 굳이 고려하지 않아도 된다.<br>

<br>

<br>

## 목차

- [참고자료](#참고자료)
- [샤딩을 고려해야 하는 경우들](#샤딩을-고려해야-하는-경우들)
  - 1) 저장소(storage) 분산이 필요한 경우
  - 2) 부하(load) 를 분산시켜야 하는 경우
- [수직적 스케일링, 수평적 스케일링](#수직적-스케일링-수평적-스케일링)
  - TODO 정리 필요
- [단일 인스턴스와 샤드 클러스터](#단일-인스턴스와-샤드-클러스터)
- [샤드 클러스터의 구성요소](#샤드-클러스터의-구성요소)
  - [mongod vs mongos ??](#mongod-vs-mongos-)
  - [샤드](#샤드-shard)
  - [설정서버](#설정-서버-config-server)
  - [mongos 라우터](#mongos-라우터)
- [샤드키](#샤드키)
- [프라이머리 샤드](#프라이머리-샤드)
- [수직샤딩과 수평샤딩](#수직샤딩과-수평샤딩)

  - TODO 정리 필요
- [샤딩에 사용되는 다양한 기술들](#샤딩에-사용되는-다양한-기술들)
  - [청크](#청크)
  - [밸런서](#밸런서)
  - [샤딩의 종류](#샤딩의-종류)
    - TODO 아래에서부터 틈나는 대로 정리필요!!!
    - [범위 샤딩](#범위-샤딩)
    - [해시 샤딩](#해시-샤딩)
  - [샤딩 구역설정](#샤딩-구역-설정)
    - [샤딩 구역을 설정하는 방법](#샤딩-구역을-설정하는-방법)
    - [샤딩 구역이 필요한 상황](#샤딩-구역이-필요한-상황)<br>

<br>

## 참고자료

- 주교재<br>
  - [몽고디비 인 액션](http://www.yes24.com/Product/Goods/60659843)<br>
- 부교재<br>
  - [맛있는 MongoDB](http://www.yes24.com/Product/Goods/85011885)<br>
- 공식문서<br>
  - [docs.mongodb.com - Data Partitioning with Chunks](https://docs.mongodb.com/manual/core/sharding-data-partitioning/)<br>
  - [docs.mongodb.com - Development Configuration](https://docs.mongodb.com/manual/core/sharded-cluster-components/)<br>
  - [docs.mongodb.com - Distributed Queries](https://docs.mongodb.com/manual/core/distributed-queries/)<br>

<br>

## 샤딩을 고려해야 하는 경우들

일반적으로 샤딩을 적용하는 것을 검토하게 되는 주요 목적은 아래의 두가지(저장소 분산, 부하 분산)이다.<br>

**1) 저장소(storage) 분산이 필요한 경우**<br>

- 현재 저장소의 용량이 초과되고 있지만 더 많은 용량을 추가하기 어려운 경우 샤딩이 최선의 방법이 될 수 있다.<br>

<br>

**2) 부하(load) 를 분산시켜야 하는 경우**<br>

- 물리적인 램 공간의 한계를 키우기 어려울 때<br>
  - 인덱스, 작업 데이터 세트는 램에 유지하는 것이 중요하다 ([몽고디비 인 액션 > 8장](http://www.yes24.com/Product/Goods/60659843)). 하지만 이 인덱스와 데이터 세트가 무한대로 계속 증가하면 램이 허용하는 한도를 넘어서게 되는 경우가 있을 수 있다. **이런 경우 역시 샤딩이 필요하게 된다.** 물론 샤딩을 하지 않고도 램을 추가하면 되지만, 램을 무한히 장착할 수 없는 상황 역시 존재한다.(Amazon EC2 의 가용 인스턴스 초과, 물리적인 램 포트 부족 등등) <br>
- 쓰기 부하가 많을 때<br>
  - 쓰기 부하가 많은 경우, 데이터가 램의 크기에 도달(data-to-RAM)하기 전에 샤딩을 적용하면 좋다. 원하는 쓰기 처리율을 얻기 위해 여러 대의 서버에 부하를 분산시켜서 쓰기 처리율을 안정적으로 가져가기 위한 용도로 샤딩을 적용한다. <br>

<br>

단, 샤딩은 모든 성능 문제를 해결하는 것은 아니다. 샤딩을 적용함으로써 추가적인 복잡성, 오버헤드를 발생하기 때문에 샤딩을 사용해야 하는 상황, 목적을 파악해야 한다.<br>

<br>

> **참고) 저장소 용량 확인 방법**<br>
>
> 현재 저장소의 용량을 확인하는 것은 모니터링을 통해 가능하다. MongoDB는 모든 데이터를 `--dbpath` 옵션으로 지정된 디렉터리에 파일 형태로 저장한다. 이 파일은 다양한 유틸리티로 모니터링이 가능하다. 또는 mongo 셸에서 db.stats(), db.collection.stats() 를 실행하면 database와 collection 에 대한 통계가 각각 출력된다.<br>

<br>

## 수직적 스케일링, 수평적 스케일링

TODO 정리 필요<br>

<br>

## 단일 인스턴스와 샤드 클러스터

보통 개발 버전의 몽고DB를 사용할 때 단일 서버로 사용하는 편이다. 이렇게 단일 인스턴스로 구성되어 있는 경우 mongod 인스턴스가 애플리케이션 **데이터의 전체 사본**을 포함하고 있는다. 그리고 이 때 복제를 사용하게 되면, 복제 역시 전체 데이터에 대해서 이뤄진다.<br>

이렇게 단일 인스턴스로 운영할 때 데이터가 커지고, 읽기-쓰기 처리량이 늘어나면, 범용 서버로는 충분하지 않으며, CPU코어를 계속 늘리는 것에도 물리적인 한계에 도달하게 된다. 또한 비용적인 한계 역시 존재한다. 하나의 디스크 또는 RAID 어레이 등에 데이터 세트의 백업을 저장하는데, 디스크 역시 크기가 커지면 이 역시 불가능하게 될 수 있다.<br>

레플리케이션 세트로 구성했던 서버 역시도 애플리케이션의 운영기간이 길어질 수록 차지하는 디스크 크기도 커지고, 읽고 쓰는 양이 많아졌을때, 더 이상 사양을 올리고 서버를 증설하면 비용적인 측면에서 손해가 될때가 있다. 이때 같은 크기로 여러개의 레플리케이션 세트를 구성하는 것보다는 샤딩을 통해 데이터의 구간을 분할한 샤드들의 클러스터인 **샤드 클러스터**를 구성한다면 각각의 샤드에 대한 리소스는 저렴하면서 여러개를 구축해 비용적으로도, 성능적인 면에서도 안정성있게 구축할 수 있다.<br>

<br>

## 샤드 클러스터의 구성요소

샤드 클러스터는 샤드, mongos 라우터, 설정 서버로 구성된다.<br>

샤드 클러스터 내에서 각각의 샤드 구성원과 애플리케이션이 통신을 할때 mongod 프로세스, mongos 프로세스를 이용한다.<br>

<br>

### mongod vs mongos ??

![이미지](https://docs.mongodb.com/manual/images/sharded-cluster-test-architecture.bakedsvg.svg)

이미지 출처 : [https://docs.mongodb.com/manual/core/sharded-cluster-components/](https://docs.mongodb.com/manual/core/sharded-cluster-components/)  

`mongod`<br>

- `mongod` 는 싱글 인스턴스 기반의 몽고 DB를 기동시킬 때에도 돌아가는 MongoDB 데몬 프로세스이다.<br>

<br>

`mongos`<br>

- `mongos` 는 애플리케이션 서버에서 샤드 클러스터 내의 각각의 샤드 클러스터 들 중 어떤 샤드 구성원들에 접속할 지를 결정하는 클라이언트 측의 로드밸런서와 같은 역할을 수행한다. <br>

<br>

샤드 클러스터를 구성하는 각각의 구성원들과 역할은 아래와 같다.<br>

<br>

![이미지](https://docs.mongodb.com/manual/images/sharded-cluster.bakedsvg.svg)

이미지 출처 : [https://docs.mongodb.com/manual/core/distributed-queries/](https://docs.mongodb.com/manual/core/distributed-queries/)<br>

<br>

### 샤드 (Shard)

- 애플리케이션 데이터를 저장한다.<br>
- 각각의 샤드는 복제(Replication)를 통해서 레플리케이션 세트로 구성가능하다.<br>
  
  - 데이터의 구간을 나누어 분할한 부분을 레플리케이션 세트로 구성해 이중화한것.<br>
- 애플리케이션에서 샤드에 접속하기 위해서는 mongos 를 통해서 샤드에 접속한다.<br>
- 이 mongos라는 것은 라우터라고도 부른다.(아래에서 정리)<br>

<br>

### 설정 서버 (Config Server)

- 클러스터 메타데이터를 영구적으로 저장<br>
- 라우터는 설정서버의 메타데이터들을 가지고 있는다. (라우터는 이 메타데이터들을 기반으로 어떤 샤드에 조회요청할지를 결정한다.)<br>
- 저장하는 데이터들의 예)<br>
  - 샤드가 속한 어떤 데이터 집합에 속하는지 에 대한 정보<br>
  - 샤드 클러스터가 동작했던 로그<br>

<br>

### mongos 라우터

- 클러스터 메타데이터를 캐시하는 역할을 수행<br>
- 메타데이터 정보를 기반으로 샤드를 선택해 작업을 라이팅하거나 샤딩한다.<br>
- mongos는 애플리케이션에 붙어있는 접속을 위한 하나의 커넥터 프로그램이라고 생각하면 된다.<br>
- 스프링 클라우드의 histrix에서 제공하는 ribbon 이라는 클라이언트 측의 로드밸런서처럼 mongos도 애플리케이션 측의 로드밸런서 역할을 수행한다.<br>

<br>

## 샤드키

샤드에 정보를 나누기 위해서는 정보들의 구간을 나눌 수 있는 기준이 필요하다. 이때 이러한 정보들의 구간을 나누는 기준이 되는 필드를 `샤드키` 라고 부른다. MongoDB 에서의 **샤드키**는 반드시 인덱싱이 되어 있는 필드에 적용하도록 제약조건이 있다.<br>

**샤드키**는 정보의 구간을 파악할 수 있고, 특정위치에 있는 정보를 찾는 기준이기 때문에 샤드 클러스터 내에서 읽기 등의 연산시마다 **샤드키**의 사용빈도가 높을 수 밖에 없다.<br>

<br>

**샤드가 적용되어도 속도가 저하되는 경우**  

> 현실세계의 데이터들은 모두 균형적으로 분포하지는 않는다. 예를 들면 우리나라의 성을 예로 들 수 있다. 우리나라의 성씨는 '이'씨에 몰려 있다. 누군가에게 들었는데 300명 정도 있는 대학교 전체 단톡방같은 경우도 이씨가 가장 많은 경우가 많다고 들은것 같기도 하다. 이렇게 데이터의 구간을 성씨로 지정할 경우 '이'씨 데이터에 대한 인덱스만을 주기적으로 조회하게 되기 때문에 다른 샤드들은 쉬고 있을 때 '이'씨 데이터를 포함하고 있는 샤드의 부하가 더 높을 수 밖에 없다.  

<br>

<br>

## 프라이머리 샤드

`프라이머리 샤드`는 데이터베이스 내에서 컬렉션을 저장하는 기본 샤드이다. 샤딩을 적용한 데이터베이스는 프라이머리 샤드가 반드시 존재해야 한다. 샤딩이 적용되어 있지 않던 상태에서 샤딩을 적용하고 나면, 과거의 데이터베이스를 저장하고 있는 서버 인스턴스가 위치한 샤드가 프라이머리 샤드가 된다.<br>

샤드 클러스터를 설정한 이후에는 각각의 데이터베이스에 샤딩을 허용할 수 있는지 등의 옵션을 개별적으로 설정하는 것 역시 가능하다. 데이터베이스 내부의 컬렉션들 각각에도, 데이터베이스에 샤딩을 적용하고 나서 샤딩을 적용하는 것 역시 가능하다.<br>

<br>

<br>

## 수직샤딩과 수평샤딩

TODO 정리 필요<br>

<br>

<br>    

## 샤딩에 사용되는 다양한 기술들

개발자가 알아야 할 정도인 개념들은 아닌 것 같다. 하지만, 장애가 발생하거나 했을 때 이런 배경지식들이 도움이 되는 경우가 있기 때문에 이 또한 무시할 수 없는 것 같아서 정리를 하게 되었다.<br>

<br>

### 청크

참고자료 : [Data Partitioning with Chunks](https://docs.mongodb.com/manual/core/sharding-data-partitioning/)  

![이미지](https://docs.mongodb.com/manual/images/sharding-range-based.bakedsvg.svg)

이미지 출처 : [https://docs.mongodb.com/manual/core/sharding-data-partitioning/](https://docs.mongodb.com/manual/core/sharding-data-partitioning/)  


컬렉션의 각 정보는 청크로 분할된다. 그리고 이렇게 분할된 각각의 청크는 샤드 클러스터 내의 샤드로 분배된다. (MongoDB splits the chunk based on the shard key values the chunk represent. A chunk may be split into multiple chunks where necessary.)

<br>

<br>


### 밸런서

참고자료 : [Data Partitioning with Chunks](https://docs.mongodb.com/manual/core/sharding-data-partitioning/)  

밸런서는 각 샤드의 청크 수를 모니터링하는 백그라운드 프로세스이다. 샤드 클러스터의 밸런서(Balancer)는 한쪽 샤드에 대해서만 청크가 몰릴 경우 샤드 사이의 청크를 교환해주는 역할을 한다. 샤드의 청크 수가 마이그레이션 임계값에 도달하면 샤드당 동일한 청크 수에 도달하도록 마이그레이션을 시도한다. 샤드 내부에 메모리 공간이 얼마 남지 않았다면 메모리가 꽉 차기 전에 청크 마이그레이션을 시도하게 된다.<br>   

![이미지](https://docs.mongodb.com/manual/images/sharding-splitting.bakedsvg.svg)

이미지 출처 : [https://docs.mongodb.com/manual/core/sharding-data-partitioning/](https://docs.mongodb.com/manual/core/sharding-data-partitioning/)<br>

<br>

<br>

### 샤딩의 종류

#### 범위 샤딩



#### 해시 샤딩



### 샤딩 구역 설정

#### 샤딩 구역을 설정하는 방법

#### 샤딩 구역이 필요한 상황


