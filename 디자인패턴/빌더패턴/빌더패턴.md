# 빌더패턴

개념정리는 요약된 형태로 9~10 문장 이내의 문장으로만 정리할 예정이다. 더 자세한 내용은 [백기선님의 스터디 자료](https://github.com/keesun/study/blob/master/effective-java/item2.md) 을 보고 복습하는게 나을 것 같다. 아무리 직접 개념을 정리하려고 해도, 나도 모르게 베끼는게 아닌가?하는 생각이 들어서이다.<br>

단순히 요약된 몇 개의 문장과 내 의견을 조금 섞어서 개념을 정리해보고, 예제 위주로 정리해볼 예정이다.<br>

<br>

## 목차

- [참고자료](#참고자료)<br>
- [아쉬운 점](#아쉬운-점)<br>

<br>

## 참고자료

- [Adopting Builder Patter with Abstract class](https://cindystlai.wordpress.com/2017/04/20/adopting-builder-pattern-with-abstract-class/)<br>
  - Enum 을 조합하는 것이 아닌 Dto 를 빌드하는 빌더패턴을 구현할 것이기 때문에 이 자료가 가장 도움이 되었다.<br>
- [백기선님의 스터디 자료](https://github.com/keesun/study/blob/master/effective-java/item2.md)를 보면서 아이디어를 얻었고 구글에서 자료 검색 후 [Adopting Builder Patter with Abstract class](https://cindystlai.wordpress.com/2017/04/20/adopting-builder-pattern-with-abstract-class/)의 자료가 더 내 예제에 잘 맞는 케이스였던것 같다.<br>
- [altongmon.tistory.com - T extends 타입, 와일드카드 타입, 제너릭 타입 상속](https://altongmon.tistory.com/241)<br>

- [HttpStatus 상태코드 (SpringFramework)](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/HttpStatus.java) <br>
  - enum 기반의 HttpStatus 상태코드를 참고해서, 예제에 필요한 부분들만을 추려내서 구현<br>
  - 참고 : [github/spring-projects/spring-framework/.../HttpStatus.java](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/HttpStatus.java)<br>

<br>

## 아쉬운 점

초반에 예제로 뭘 만들어야하나 하고 조금 막막했다. 아무 생각없이 만들어보다보니... **아하... RequestDto 를 빌더패턴으로 구현하려 했던게 내 마음속 상상이었는데 ResponseDto를 만들어버렸네?** 하는 생각이 들었더랬다. **그런데 막상 또 생각해보니 ResponseDto 역시도 제품 내에서공통적인 규격화를 하려고 한다면 필요하지 않을까?** 하는 생각을 했다.<br>

결론은... 나중에 RequestDto Builder 역시도 예제로 한번 더 만들어볼 예정이다 🙂<br>

<br>

## Builder 패턴을 사용하는 이유

보통 객체를 생성할 때 멤버 필드들을 초기화할 때 생성과 동시에 초기화하는 경우가 많다. 그리고 멤버 필드는 final로 선언한다. 즉, 생성자 내에서 객체의 초기화를 수행한다. 이렇게 하는 이유는 멀티스레드 환경에서 객체의 불변성을 확보하기 위해서이다. 예를 들면 아래와 같이 생성자를 쓰는 경우가 많다.<br>

```java
class UserProfileDto{
  final String nickName;
  final String city;
  public UserProfileDto(final String nickName, final String city){
    this.nickName = nickName;
    this.city = city;
  }
}
```

<br>

위의 경우는 필드가 nickName 과 city 두개 밖에 없지만, 보통 필드들이 30개 이상을 넘어가는 경우도 굉장히 많을 것이다. 이 때 생성자에 일일이 30개 이상의 final 필드들에 대해 생성자로 나열할 경우 생성자 코드를 작성하는 것도 중노동이고, 해당 생성자의 인자를 하나 하나 맞추는 작업도 중노동일 것 같다.<br>

```java
class UserProfileDto{
  final String nickName;
  final String city;
  final String val1;
  final String val2;
  final String val3;
  final String val4;
  final String val5;
  final String val6;
  final String val7;
  
  public UserProfileDto(String nickName, String city, String val1, String val2, ... ){
    this.nickName = nickName;
    this.city = city;
    this.val1 = val1;
    // ...
  }
}
```

<br>

이렇게 인자가 많은 생성자를 만들 경우에 대해, Java 진영에서는 Builder 패턴의 사용을 권장하고 있다. Effective Java 에서 언급되는 내용인데, 자세한 내용은 [백기선님의 스터디 자료](https://github.com/keesun/study/blob/master/effective-java/item2.md) 을 참고하는 것이 나을 것 같다.<br>

<br>

내 생각은 빌더 패턴을 인자가 많은 생성자 대신에 사용하는 이유는 아래의 두 가지가 주요한 이유인 것 같다.<br>

- 생성자의 인자가 많을 경우, 구현상의 편의성과 높은 유지보수성을 제공하기 위해 필요<br>
- 객체 생성 직후의 필드의 불변을 보장해야 하는데, 생성자의 인자가 매우 많을 경우, 빌더 패턴으로 구현해 구현상의 편리함과 높은 유지보수성을 제공하기 위해 필요<br>

<br>

예를 들면 위의 UserProfileDto 클래스는 아래와 같이 변경가능하다.<br>

```java
package io.study.design_pattern.builder.messenger.response;

public class UserProfileDto {
	private String nickName;	// 닉네임
	private String city;		// 주거지역

	public UserProfileDto(){}

	public static class Builder{
		private final UserProfileDto actualInstance = new UserProfileDto();

		public Builder(){}

		public Builder self(){
			return this;
		}

		public UserProfileDto build(){
			return actualInstance;
		}

		public Builder nickName(String nickName){
			actualInstance.setNickName(nickName);
			return self();
		}

		public Builder city(String city){
			actualInstance.setCity(city);
			return self();
		}
	}

	private void setNickName(String nickName) {
		this.nickName = nickName;
	}

	private void setCity(String city) {
		this.city = city;
	}

	public String getNickName() {
		return nickName;
	}

	public String getCity() {
		return city;
	}

	@Override
	public String toString() {
		return "UserProfileDto{" +
			"nickName='" + nickName + '\'' +
			", city='" + city + '\'' +
			'}';
	}
}
```

<br>

## 예제 1. 간단한 버전의 Builder - UserProfileDto

UserProfileDto 라는 이름의 클래스를 Builder 패턴을 통해 구현한 것을 확인해보자.

```java
package io.study.design_pattern.builder.messenger.response;

public class UserProfileDto {
	private String nickName;	// 닉네임
	private String city;		// 주거지역

	public UserProfileDto(){}

	public static class Builder{
		private final UserProfileDto actualInstance = new UserProfileDto();

		public Builder(){}

		public Builder self(){
			return this;
		}

		public UserProfileDto build(){
			return actualInstance;
		}

		public Builder nickName(String nickName){
			actualInstance.setNickName(nickName);
			return self();
		}

		public Builder city(String city){
			actualInstance.setCity(city);
			return self();
		}
	}

	private void setNickName(String nickName) {
		this.nickName = nickName;
	}

	private void setCity(String city) {
		this.city = city;
	}

	public String getNickName() {
		return nickName;
	}

	public String getCity() {
		return city;
	}

	@Override
	public String toString() {
		return "UserProfileDto{" +
			"nickName='" + nickName + '\'' +
			", city='" + city + '\'' +
			'}';
	}
}

```

<br>

코드를 자세히 보면 아래와 같은 몇가지 주요 특징들이 눈에 띈다.<br>

- UserProfileDto 클래스 내의 setter 들이 모두 private 로 선언되어 있다.<br>
- UserProfileDto 객체는 내부클래스인 Builder 클래스 내에 final로 인스턴스화 하여 선언되어 있다.<br>

<br>

**setter 메서드들을 private 로 선언**<br>

`UserProfileDto` 클래스 내의 `nickName` , `city` 필드는 private로 선언되어 있고, setter 메서드들 역시도 모두 private 로 선언되어 있기 때문에, 런타임 시점에 외부에서 setter 를 호출하거나 개별 필드인 `nickName`, `city` 를 수정하는 것이 불가능하다. (물론 리플렉션으로 필드들을 강제로 세팅하는 것도 가능하기는 하지만, 리플렉션은 논외로 하기로 했다.)<br>

<br>

**내부 클래스 Builder 클래스 내에 final로 UserProfileDto 객체를 인스턴스화 하여 선언**<br>

자세히 보면 Bill Pugh의 싱글턴과 조금 닮아있음을 확인가능하다. 하지만 Bill Pugh의 싱글턴과 다른 점은 Inner Class 인 Builder 클래스가 public static 으로 선언되어 있다는 것이다. (Bill Pugh 싱글턴에서의 Inner Class의 경우 Inner Class 가 private 로 선언되어 있다는 점이 다르다.) <br>

Builder 클래스 내에서 UserProfileDto를 final로 생성해두어, 불변성을 확보했고, Inner Class 인 Builder 내에 UserProfileDto 인스턴스를 선언해두어 외부에서 접근하지 못하도록 해두었다.

```java
public class UserProfileDto {
	private String nickName;	// 닉네임
	private String city;		// 주거지역

	public UserProfileDto(){}
  
	public static class Builder{
		private final UserProfileDto actualInstance = new UserProfileDto();
    // ...
    public UserProfileDto build() {
      return actualInstance;
    }
  }
}
```

<br>

**테스트 코드**<br>

```java
public class BuilderPatternResponseTest {

	@Test
	void 단순_빌더패턴_UserProfileDto_테스트(){
		UserProfileDto user1 = new UserProfileDto.Builder()
			.nickName("신사임당")
			.city("부천")
			.build();

		UserProfileDto user2 = new UserProfileDto.Builder()
			.nickName("존리선생님")
			.city("뉴요크")
			.build();

		Assertions.assertNotSame(user1, user2);
	}
  
  // ...
  
}
```

<br>

**출력결과**<br>

```plain
user1 = UserProfileDto{nickName='신사임당', city='부천'}
user2 = UserProfileDto{nickName='존리선생님', city='뉴요크'}
```

<br>

## 예제 2. 조금 복잡한 버전의 Builder - ResponseDto, KakaoTalkResponseDto



